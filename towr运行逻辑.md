![](md/é€»è¾‘/rosgraph.png)

## 1. `O` (Optimize motion)

### ğŸ§© 1. `RobotModel` (æ¨¡å‹æ„å»º)

#### 1.1 **ç”Ÿæˆæ¨¡å‹**
```cpp
formulation_.model_ = RobotModel(static_cast<RobotModel::Robot>(msg.robot));
````

> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**
> **`formulation_`**ï¼šè¿™æ˜¯ä¼˜åŒ–é—®é¢˜çš„æ€»å®šä¹‰å¯¹è±¡ã€‚
> æ­¤å¤„é€šè¿‡å·¥å‚æ¨¡å¼æ„é€  `model_`ï¼Œå†…éƒ¨åŒ…å«ä¸¤ä¸ªæ ¸å¿ƒç»„ä»¶ï¼š**è¿åŠ¨å­¦æ¨¡å‹** (`Kinematic`) å’Œ **åŠ¨åŠ›å­¦æ¨¡å‹** (`Dynamic`)ã€‚

-----
>eg:src/towr/towr/include/towr/models/examples/biped_model.h

##### ğŸ¦µ 1.1.1 è¿åŠ¨å­¦æ¨¡å‹ (`xxxKinematicModel`)

*ç»§æ‰¿è‡ª `KinematicModel`ï¼Œå®šä¹‰â€œèº«æâ€ä¸â€œæ´»åŠ¨èŒƒå›´â€ã€‚*

  * **åˆå§‹åŒ–å‚æ•° 1ï¼šè…¿éƒ¨æ•°é‡**

    ```cpp
    KinematicModel(2)
    ```

    * **å«ä¹‰**ï¼šåˆå§‹åŒ–çˆ¶ç±»ï¼Œå‘ŠçŸ¥ç³»ç»Ÿâ€œæˆ‘æ˜¯ä¸€ä¸ª **2æ¡è…¿** (Endeffectors) çš„æœºå™¨äººâ€ã€‚

  * **åˆå§‹åŒ–å‚æ•° 2ï¼šåä¹‰ç«™ç«‹å§¿æ€ (`nominal_stance_`)**

    ```cpp
    const double z_nominal_b = -0.65; // èº«é«˜/è…¿é•¿
    const double y_nominal_b =  0.20; // åŠè·¨å®½

    nominal_stance_.at(L) << 0.0,  y_nominal_b, z_nominal_b; // å·¦è„š
    nominal_stance_.at(R) << 0.0, -y_nominal_b, z_nominal_b; // å³è„š
    ```

      * **å«ä¹‰**ï¼šå®šä¹‰æœºå™¨äººæœ€è‡ªç„¶ã€é»˜è®¤çš„ç«™ç«‹å§¿æ€ï¼ˆç›¸å¯¹äº Base ä¸­å¿ƒï¼‰ã€‚
      * **å‚æ•°è§£æ**ï¼š
          * `z = -0.65`: è„šåœ¨èº«ä½“ä¸‹æ–¹ **0.65ç±³**ã€‚
          * `y = Â±0.20`: ä¸¤è„šé—´è·æ€»å®½ **0.4ç±³**ã€‚

    > ğŸ¤– **ç‰©ç†ç”»é¢æ„Ÿ**
    > æƒ³è±¡æœºå™¨äººæ‚¬åœ¨åŠç©ºä¸­ï¼Œèº«ä½“ä¸­å¿ƒæ˜¯åŸç‚¹ `(0,0,0)`ã€‚è¿™ä¸¤è¡Œä»£ç æŠŠå®ƒçš„ä¸¤åªè„šâ€œæ‘†â€åˆ°äº†å®ƒè¯¥åœ¨çš„ç©ºé—´ä½ç½®ã€‚

  * **åˆå§‹åŒ–å‚æ•° 3ï¼šæœ€å¤§æ´»åŠ¨èŒƒå›´ (`max_dev_from_nominal_`)**

    ```cpp
    max_dev_from_nominal_ << 0.25, 0.15, 0.15;
    ```

      * **å«ä¹‰**ï¼šå®šä¹‰è…¿çš„å·¥ä½œç©ºé—´ï¼ˆWorkspaceï¼‰ï¼Œå‘Šè¯‰ä¼˜åŒ–å™¨è…¿ä¸èƒ½æ— é™ä¼¸é•¿ã€‚
      * **é™åˆ¶èŒƒå›´**ï¼ˆç›¸å¯¹äºåä¹‰ä½ç½®ï¼‰ï¼š
          * **Xè½´ (å‰å)**: $\pm 0.25m$ (è¿ˆæ­¥/è¹¬åœ°æé™)
          * **Yè½´ (å·¦å³)**: $\pm 0.15m$ (æ‘†åŠ¨æé™)
          * **Zè½´ (ä¸Šä¸‹)**: $\pm 0.15m$ (ä¸‹è¹²/æè…¿æé™)

-----

##### âš–ï¸ 1.1.2 åŠ¨åŠ›å­¦æ¨¡å‹ (`xxxDynamicModel`)

*ç»§æ‰¿è‡ª `SingleRigidBodyDynamics`ï¼Œå®šä¹‰â€œä½“é‡â€ä¸â€œä½“è´¨â€ã€‚*

**æ„é€ å‡½æ•°ï¼š**

```cpp
: SingleRigidBodyDynamics(20, 1.209, 5.583, 6.056, 0.005, -0.190, -0.012, 2)
```

1.  **è´¨é‡ (Mass)**

      * **å€¼**ï¼š`20` (kg)
      * **ä½œç”¨**ï¼šåŸºäº $F=ma$ï¼Œå†³å®šäº†ä¼˜åŒ–å™¨éœ€è¦è®¡ç®—å¤šå¤§çš„æ¨åŠ›æ¥é©±åŠ¨æœºå™¨äººã€‚

2.  **è½¬åŠ¨æƒ¯é‡ (Inertia Tensor)**

      * **å€¼**ï¼š`1.209, 5.583, 6.056, ...`

      * **å«ä¹‰**ï¼šè¿™ 6 ä¸ªæ•°å€¼æ„æˆäº† $3 \times 3$ çš„å¯¹ç§°æƒ¯æ€§çŸ©é˜µ $I$ï¼š

        $$
        I = \begin{bmatrix} I_{xx} & I_{xy} & I_{xz} \\ I_{yx} & I_{yy} & I_{yz} \\ I_{zx} & I_{zy} & I_{zz} \end{bmatrix}
        $$

      * **ä¸»å¯¹è§’çº¿** (`1.209`, `5.583`, `6.056`)ï¼šå¯¹åº” $I_{xx}, I_{yy}, I_{zz}$ã€‚æ•°å€¼è¶Šå¤§ï¼Œç»•è¯¥è½´è½¬åŠ¨è¶Šéš¾ã€‚

      * **éå¯¹è§’çº¿** (`0.005`, ...): æƒ¯æ€§ç§¯ï¼Œè¡¨ç¤ºè´¨é‡åˆ†å¸ƒçš„ä¸å¯¹ç§°æ€§ã€‚

3.  **è…¿éƒ¨è®¡æ•°**

      * **å€¼**ï¼š`2`
      * **ä½œç”¨**ï¼šå†æ¬¡ç¡®è®¤è…¿éƒ¨æ•°é‡ï¼Œç”¨äºæ¥è§¦åŠ›å˜é‡åˆå§‹åŒ–ã€‚

-----
#### 1.2**å‘å¸ƒæœºå™¨äººå‚æ•°æ¶ˆæ¯æ„å»º**

```cpp
  auto robot_params_msg = BuildRobotParametersMsg(formulation_.model_);
  robot_parameters_pub_.publish(robot_params_msg);
````
##### 1.2.1 xpp_msgs::RobotParameters
```cpp
# Parameters used to generate this optimization/trajectory
# Should basically save class xpp::OptimizationParameters

# endeffector names (order of endeffectors, e.g. LF, RF, LH, RH)
string[] ee_names  # è…¿çš„åå­—

geometry_msgs/Point[]   nominal_ee_pos    # åˆå§‹çŠ¶æ€ä¸‹è…¿çš„ä½ç½®
geometry_msgs/Vector3   ee_max_dev        # æœ€å¤§æ´»åŠ¨èŒƒå›´

float64                 base_mass         # é‡é‡ (for plotting gravity force)             
````
>å¯ä»¥çœ‹å‡ºæ¥BuildRobotParametersMsgå·²ç»å…¨æ˜¯è°ƒç”¨RobotModelçš„å‚æ•°ï¼Œè¿™äº›å‚æ•°åªè¦åœ¨KinematicModelå’ŒSingleRigidBodyDynamicså®šä¹‰å¥½å°±ä¸ç”¨ç®¡

>ğŸ’¡åˆ°ç°åœ¨çœ‹æ‡‚äº†å®šä¹‰ä¸€ä¸ªæ¨¡å‹éœ€è¦å†™ä¸€ä¸ªmodels/robot_model.hä¸examples/biped_model.h.

### ğŸ§© 2. `terrain` (åœ°å½¢æ„å»º)

#### 2.1 **ç”Ÿæˆåœ°å½¢**
```cpp
  auto terrain_id = static_cast<HeightMap::TerrainID>(msg.terrain);
  formulation_.terrain_ = HeightMap::MakeTerrain(terrain_id);
````
```cpp
HeightMap::MakeTerrain (TerrainID type)
{
  switch (type) {
    case FlatID:      return std::make_shared<FlatGround>(); break;
    case BlockID:     return std::make_shared<Block>(); break;
    case StairsID:    return std::make_shared<Stairs>(); break;
    case GapID:       return std::make_shared<Gap>(); break;
    case SlopeID:     return std::make_shared<Slope>(); break;
    case ChimneyID:   return std::make_shared<Chimney>(); break;
    case ChimneyLRID: return std::make_shared<ChimneyLR>(); break;
    default: assert(false); break;
  }
}
````

>éšä¾¿è§£æä¸€ä¸ªå§ï¼Œçœ‹çœ‹ChimneyLR

>å‘ç°åªæœ‰ä¸¤ä¸ªå…³é”®ç‚¹ï¼Œä¸€ä¸ªæ˜¯è®°å½•æ¯ä¸ªåœ°æ–¹çš„é«˜åº¦
```cpp
class ChimneyLR : public HeightMap {
public:
  double GetHeight(double x, double y) const override;
  double GetHeightDerivWrtY(double x, double y) const override;

private:
  const double x_start_ = 0.5;
  const double length_  = 1.0;
  const double y_start_ = 0.5; // ä¸–ç•Œåæ ‡y=5çš„ä½ç½®zä¸º0 
  const double slope_   = 2;

  const double x_end1_ = x_start_+length_;
  const double x_end2_ = x_start_+2*length_;
};
```
>è¿˜æœ‰å°±æ˜¯è·å–é«˜åº¦
```cpp
double
// Chimney LR
double
ChimneyLR::GetHeight (double x, double y) const
{
  double z = 0.0;

  if (x_start_<=x && x<=x_end1_)
    z = slope_*(y-y_start_);

  if (x_end1_<=x && x<=x_end2_)
    z = -slope_*(y+y_start_);

  return z;
}

double
ChimneyLR::GetHeightDerivWrtY (double x, double y) const
{
  double dzdy = 0.0;

  if (x_start_ <= x && x <= x_end1_)
    dzdy = slope_;

  if (x_end1_<=x && x<=x_end2_)
    dzdy = -slope_;

  return dzdy;
}

```

>è¿™é‡Œæ˜¯æ€ä¹ˆæ„å»ºåœ°å½¢çš„
 ```
  X è½´ (å‰è¿›æ–¹å‘) --->
Start (0.0)      x_start_(0.5)      x_end1_(1.5)       x_end2_(2.5)
|----------------|------------------|------------------|----------------|
|    å¹³åœ°é˜¶æ®µ    |   é˜¶æ®µ A (å·¦å€¾)  |   é˜¶æ®µ B (å³å€¾)  |    å¹³åœ°é˜¶æ®µ    |
|    Flat        |   Slope = +2     |   Slope = -2     |    Flat        |
|----------------|------------------|------------------|----------------|
```

### 3. `Configuration` (å‚æ•°ä¸ç›®æ ‡é…ç½®)

**ä»£ç ç‰‡æ®µï¼š**
```cpp
int n_ee = formulation_.model_.kinematic_model_->GetNumberOfEndeffectors();
formulation_.params_ = GetTowrParameters(n_ee, msg);
formulation_.final_base_ = GetGoalState(msg);
```

#### â±ï¸ 3.1 `GetTowrParameters` (æ­¥æ€ä¸æ—¶åºé€»è¾‘)
*è¿™æ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼Œå®é™…æ‰§è¡Œçš„æ˜¯ `TowrRosApp` ä¸­çš„é‡å†™ç‰ˆæœ¬ã€‚*

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**
```cpp
// 1. åˆ›å»ºæ­¥æ€ç”Ÿæˆå™¨å·¥å‚
auto gait_gen_ = GaitGenerator::MakeGaitGenerator(n_ee);

// 2. è®¾ç½®æ­¥æ€ç±»å‹ (Walk, Trot, Pace...)
auto id_gait = static_cast<GaitGenerator::Combos>(msg.gait);
gait_gen_->SetCombo(id_gait);

// 3. ä¸ºæ¯ä¸€æ¡è…¿ç”Ÿæˆç›¸ä½æ—¶é—´è¡¨
for (int ee=0; ee<n_ee; ++ee) {
  params.ee_phase_durations_.push_back(gait_gen_->GetPhaseDurations(msg.total_duration, ee));
  params.ee_in_contact_at_start_.push_back(gait_gen_->IsInContactAtStart(ee));
}
````

**é€»è¾‘æ·±åº¦è§£æï¼š**

1.  **å·¥å‚æ¨¡å¼ (`MakeGaitGenerator`)**ï¼šæ ¹æ®è…¿çš„æ•°é‡ï¼ˆ`n_ee`ï¼‰ï¼Œè‡ªåŠ¨å†³å®šæ˜¯åˆ›å»ºå››è¶³ç”Ÿæˆå™¨è¿˜æ˜¯åŒè¶³ç”Ÿæˆå™¨ã€‚
2.  **ç¿»è¯‘è¿‡ç¨‹**ï¼š
      * **è¾“å…¥**ï¼šç”¨æˆ·åªç»™äº†ä¸€ä¸ªç®€å•çš„æšä¸¾å€¼ `msg.gait` (ä¾‹å¦‚ `Trot`) å’Œæ€»æ—¶é—´ `total_duration`ã€‚
      * **è¾“å‡º**ï¼šä»£ç å°†å…¶å±•å¼€ä¸ºæ¯æ¡è…¿çš„**è¯¦ç»†æ—¶é—´è¡¨**ã€‚
      * *ä¾‹å¦‚ Trot (å››è¶³å°è·‘)*ï¼šå®ƒä¼šç”Ÿæˆç±»ä¼¼â€œå·¦å‰è…¿å’Œå³åè…¿åŒæ—¶ç€åœ°ï¼Œå¦å¤–ä¸¤å¯¹åŒæ—¶è…¾ç©ºâ€çš„äº¤æ›¿åºåˆ—ã€‚
3.  **ç›¸ä½ä¼˜åŒ– (`OptimizePhaseDurations`)**ï¼š
    ```cpp
    if (msg.optimize_phase_durations)
      params.OptimizePhaseDurations();
    ```
    å¦‚æœå¼€å¯æ­¤å¼€å…³ï¼Œåˆšæ‰ç”Ÿæˆçš„â€œæ¥è§¦/è…¾ç©ºæ—¶é—´â€å°±å˜æˆäº†**å˜é‡**ã€‚æ±‚è§£å™¨å¯ä»¥å¾®è°ƒè¿™äº›æ—¶é—´ï¼ˆæ¯”å¦‚æŠŠè¿™ä¸€æ­¥è¿ˆå¾—æ…¢ä¸€ç‚¹ï¼Œä¸‹ä¸€æ­¥å¿«ä¸€ç‚¹ï¼‰æ¥é€‚åº”åœ°å½¢ã€‚å¦‚æœä¸å¼€å¯ï¼Œæ—¶é—´å°±æ˜¯å†™æ­»çš„å›ºå®šå€¼ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿ (Step-by-Step)ï¼š**
>
>   * **`id_gait`**: æ£€æŸ¥æšä¸¾å€¼ã€‚`0`=Stand, `1`=Walk, `2`=Trot, `3`=Pace ç­‰ï¼ˆéœ€å¯¹ç…§ `GaitGenerator` å¤´æ–‡ä»¶ï¼‰ã€‚
>   * **`ee_phase_durations_`**: è¿™æ˜¯ä¸€ä¸ª `vector<vector<double>>`ã€‚
>       * æŒ‰ `p params.ee_phase_durations_` æŸ¥çœ‹ã€‚
>       * *é¢„æœŸ*ï¼šå¦‚æœæ˜¯ `Trot`ï¼Œä½ åº”è¯¥çœ‹åˆ°ç¬¬ 0 æ¡è…¿å’Œç¬¬ 3 æ¡è…¿çš„æ—¶é—´åºåˆ—æ˜¯ä¸€æ ·çš„ï¼Œè€Œç¬¬ 1 å’Œ ç¬¬ 2 æ¡è…¿æ˜¯é”™å¼€çš„ã€‚
>       * *å€¼*ï¼šä¾‹å¦‚ `[0.3, 0.4, 0.3]` è¡¨ç¤ºï¼šæ¥è§¦ 0.3s -\> æ‘†åŠ¨ 0.4s -\> æ¥è§¦ 0.3sã€‚
>   * **`ee_in_contact_at_start_`**: å†³å®šäº†æœºå™¨äººçš„åˆå§‹å§¿æ€ï¼ˆæ˜¯å››è„šç€åœ°å¼€å§‹ï¼Œè¿˜æ˜¯æŠ¬ç€è…¿å¼€å§‹ï¼‰ã€‚

-----

#### ğŸ¯ 3.2 `GetGoalState` (ç›®æ ‡çŠ¶æ€è§£æ)

*æ‰§è¡Œçš„æ˜¯ `TowrRosInterface` ä¸­çš„åŸºç±»æ–¹æ³•ã€‚*

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**

```cpp
BaseState goal;
// å°† ROS æ¶ˆæ¯ (geometry_msgs) è½¬æ¢ä¸º XPP/Eigen ç±»å‹
goal.lin.at(kPos) = xpp::Convert::ToXpp(msg.goal_lin.pos);
goal.lin.at(kVel) = xpp::Convert::ToXpp(msg.goal_lin.vel);
goal.ang.at(kPos) = xpp::Convert::ToXpp(msg.goal_ang.pos);
goal.ang.at(kVel) = xpp::Convert::ToXpp(msg.goal_ang.vel);
return goal;
```

**é€»è¾‘è§£æï¼š**

  * **åæ ‡è½¬æ¢**ï¼š`xpp::Convert::ToXpp` è´Ÿè´£æŠŠ ROS çš„ `geometry_msgs::Point/Vector3` æ•°æ®æ¬è¿åˆ° TOWR å†…éƒ¨ä½¿ç”¨çš„ `Eigen::Vector3d` æ ¼å¼ä¸­ã€‚
  * **6D çŠ¶æ€**ï¼šå®ƒä¸ä»…è®¾ç½®äº†**ä½ç½® (lin)**ï¼Œè¿˜è®¾ç½®äº†**è§’åº¦ (ang)**ï¼Œä»¥åŠå®ƒä»¬å¯¹åº”çš„**é€Ÿåº¦ (Vel)**ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥æŒ‡å®šæœºå™¨äººâ€œä»¥ 1m/s çš„é€Ÿåº¦å†²è¿‡ç»ˆç‚¹çº¿â€ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿï¼š**
>
>   * **`msg.goal_lin.pos`**: ç¡®è®¤ç›®æ ‡ç‚¹æ˜¯å¦åœ¨åˆç†èŒƒå›´å†…ã€‚
>       * *æ£€æŸ¥ Z è½´*ï¼šå¦‚æœ `z` å€¼è®¾ç½®å¾—ç¦»åœ°é¢å¤ªè¿œï¼ˆä¾‹å¦‚åœ°å½¢é«˜ 0mï¼Œç›®æ ‡è®¾åœ¨ 0.2mï¼Œä½†æœºå™¨äººè…¿é•¿åªæœ‰ 0.6mï¼‰ï¼Œæ±‚è§£å™¨å¯èƒ½ä¼šå› ä¸ºå¤Ÿä¸ç€è€ŒæŠ¥é”™ã€‚
>   * **`msg.goal_ang.vel`**: é€šå¸¸ä¸ºäº†ç¨³å®šï¼Œç»ˆç‚¹è§’é€Ÿåº¦éƒ½è®¾ä¸º 0ã€‚å¦‚æœè¿™é‡Œæœ‰éé›¶å€¼ï¼Œæœºå™¨äººå¯èƒ½ä¼šåœ¨ç»ˆç‚¹å¤„â€œæ—‹è½¬ç€åœä¸‹æ¥â€ã€‚

-----
### 4. `Initialization` (è®¾ç½®èµ·å§‹çŠ¶æ€)

#### ğŸ 4.1 `SetTowrInitialState` (èµ·å§‹å§¿æ€æ ¡å‡†)
*è¿™æ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼Œåœ¨ `TowrRosApp` ä¸­é‡å†™ã€‚*

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**
```cpp
// 1. è·å–åä¹‰å§¿æ€ (ç›¸å¯¹äºåŸºåº§ B)
auto nominal_stance_B = formulation_.model_.kinematic_model_->GetNominalStanceInBase();

// 2. å¼ºåˆ¶æŠŠæ‰€æœ‰è„šæŒ‰åœ¨åœ°é¢ä¸Š (World Frame Z = 0)
double z_ground = 0.0;
formulation_.initial_ee_W_ =  nominal_stance_B; // å…ˆå¤åˆ¶ç›¸å¯¹ä½ç½®
std::for_each(formulation_.initial_ee_W_.begin(), formulation_.initial_ee_W_.end(),
              [&](Vector3d& p){ p.z() = z_ground; } 
);//å…·ä½“è¦æ‰§è¡Œçš„ä»£ç ã€‚æŠŠå½“å‰ç‚¹ `p` çš„ Z åæ ‡æ”¹æˆ `z_ground` (0.0)ã€‚

// 3. æ ¹æ®è…¿é•¿åæ¨åŸºåº§(Base)çš„é«˜åº¦
formulation_.initial_base_.lin.at(kPos).z() = - nominal_stance_B.front().z() + z_ground;
````

**é€»è¾‘æ·±åº¦è§£æï¼š**

1.  **è·å–â€œèˆ’é€‚å§¿åŠ¿â€**ï¼š
      * `nominal_stance_B` æ‹¿åˆ°äº†æˆ‘ä»¬åœ¨ `RobotModel` é‡Œå®šä¹‰çš„å‚æ•°ï¼ˆæ¯”å¦‚è…¿é•¿ 0.65mï¼‰ã€‚æ­¤æ—¶åæ ‡æ˜¯ç›¸å¯¹äºèº«ä½“ä¸­å¿ƒçš„ï¼ˆä¾‹å¦‚ $z = -0.65$ï¼‰ã€‚
2.  **è¶³ç«¯è½åœ° (Feet on Ground)**ï¼š
      * ä»£ç é€šè¿‡ `std::for_each` éå†æ‰€æœ‰è¶³ç«¯ã€‚
      * å¼ºè¡Œå°†æ‰€æœ‰è¶³ç«¯çš„ $Z$ åæ ‡è®¾ä¸º `0.0`ã€‚è¿™æ„å‘³ç€**å‡è®¾æœºå™¨äººèµ·å§‹äºç»å¯¹å¹³å¦çš„åœ°é¢**ã€‚
3.  **æ‹”é«˜èº«ä½“ (Body Height)**ï¼š
      * **æ•°å­¦å…¬å¼**ï¼š$H_{base} = -(-0.65) + 0.0 = 0.65m$ã€‚
      * **å«ä¹‰**ï¼šæ—¢ç„¶è„šåœ¨ $z=0$ï¼Œä¸”è„šåº”è¯¥åœ¨èº«ä½“ä¸‹æ–¹ $0.65m$ å¤„ï¼Œé‚£ä¹ˆèº«ä½“å°±åº”è¯¥åœ¨ $z=0.65$ å¤„ã€‚
      * *æ³¨*ï¼šè¿™é‡Œä½¿ç”¨äº† `nominal_stance_B.front()`ï¼ˆç¬¬0æ¡è…¿ï¼‰ä½œä¸ºå‚è€ƒæ ‡å‡†æ¥è®¡ç®—èº«é«˜ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿä¸éšæ‚£ï¼š**
>
>   * **å¹³åœ°å‡è®¾**ï¼šè¿™é‡Œç¡¬ç¼–ç äº† `z_ground = 0.0`ã€‚
>       * *é£é™©*ï¼šå¦‚æœæˆ‘è®©æœºå™¨äººä»ä¸€ä¸ªå°é˜¶ä¸Š ($z=0.5$) å¼€å§‹èµ°ï¼Œè¿™æ®µä»£ç ä¼šæŠŠæœºå™¨äººçš„è„šå¼ºè¡ŒæŒ‰åˆ° $z=0$ï¼Œå¯¼è‡´åˆå§‹çŠ¶æ€æå…¶æ€ªå¼‚ï¼ˆåƒæ‹‰é¢ä¸€æ ·è¢«æ‹‰é•¿ï¼‰ï¼Œä¼˜åŒ–å™¨ä¼šç«‹åˆ»æŠ¥é”™ `Infeasible`ã€‚
>   * **åˆå§‹ä½ç½®**ï¼šè¿™æ®µä»£ç åªè®¾ç½®äº†é«˜åº¦ ($z$)ã€‚æœºå™¨äººçš„æ°´å¹³ä½ç½® ($x, y$) å’Œæœå‘ (Yaw) é»˜è®¤æ˜¯ 0ï¼ˆé™¤éåœ¨å…¶ä»–åœ°æ–¹è®¾ç½®äº† `initial_base_` çš„å…¶ä»–åˆ†é‡ï¼‰ã€‚

-----
### 5. `Solver Configuration` (æ±‚è§£å™¨é…ç½®)

#### âš™ï¸ 5.1 `SetIpoptParameters` (é…ç½® IPOPT)
*è¿™æ˜¯ä¸€ä¸ªè™šå‡½æ•°ï¼Œåœ¨ `TowrRosApp` ä¸­é‡å†™ã€‚*

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**
```cpp
// 1. é€‰æ‹©çº¿æ€§æ±‚è§£å™¨ (Linear Solver)
solver_->SetOption("linear_solver", "mumps"); // å…è´¹å¼€æºï¼Œä½†æ¯” MA27/MA57 æ…¢

// 2. è®¾ç½®å¯¼æ•°è®¡ç®—æ–¹å¼ (Derivatives)
solver_->SetOption("jacobian_approximation", "exact"); // ä½¿ç”¨è§£æå¯¼æ•°(å¿«)

// 3. è®¾ç½®èµ„æºé™åˆ¶
solver_->SetOption("max_cpu_time", 40.0); // ç®—40ç§’ç®—ä¸å‡ºæ¥å°±æ”¾å¼ƒ
solver_->SetOption("print_level", 5);     // æ‰“å°è¯¦ç»†ç¨‹åº¦ (0-12)

// 4. åˆå§‹åŒ–æ¨¡å¼ vs ä¼˜åŒ–æ¨¡å¼
if (msg.play_initialization)
  solver_->SetOption("max_iter", 0);    // è¿­ä»£0æ¬¡ = åªçœ‹åˆå€¼ï¼Œä¸ä¼˜åŒ–
else
  solver_->SetOption("max_iter", 3000); // æ­£å¸¸ä¼˜åŒ–ï¼Œæœ€å¤šè·‘3000è½®
````

**å…³é”®å‚æ•°æ·±åº¦è§£æï¼š**

1.  **`linear_solver` = "mumps"**

      * **å«ä¹‰**ï¼šè¿™æ˜¯æ±‚è§£å¤§å‹ç¨€ç–çŸ©é˜µçš„æ ¸å¿ƒç®—æ³•åº“ã€‚
      * **èƒŒæ™¯**ï¼šä»£ç æ³¨é‡Šæåˆ° `ma27`, `ma57` (æ¥è‡ª HSL åº“) ä¼šå¿«å¾ˆå¤šï¼Œä½†é‚£æ˜¯æ”¶è´¹æˆ–éœ€è¦å­¦æœ¯è®¸å¯çš„ã€‚`mumps` æ˜¯å…è´¹é€šç”¨çš„é»˜è®¤é€‰æ‹©ã€‚

2.  **`jacobian_approximation` = "exact"**

      * **å«ä¹‰**ï¼š**éå¸¸å…³é”®ï¼** è¿™å‘Šè¯‰ IPOPTï¼šâ€œåˆ«è‡ªå·±ççŒœå¯¼æ•°ï¼Œæˆ‘ä¼šç›´æ¥ç»™ä½ ç²¾ç¡®çš„å…¬å¼â€ã€‚
      * **è§£æå¯¼æ•° (Exact)**ï¼šTOWR åº“æ¨å¯¼äº†ç‰©ç†å…¬å¼çš„æ•°å­¦å¯¼æ•°ï¼Œè®¡ç®—æå¿«ã€‚
      * **æœ‰é™å·®åˆ† (Finite Difference)**ï¼šå¦‚æœè®¾ä¸ºè¿™ä¸ªï¼Œæ±‚è§£å™¨ä¼šå°è¯•ç¨å¾®ç§»åŠ¨æ¯ä¸€ä¸ªå˜é‡æ¥ä¼°ç®—æ–œç‡ï¼Œå¯¹äºè¿™ç§å¤æ‚æœºå™¨äººé—®é¢˜ï¼Œé€Ÿåº¦ä¼šæ…¢å‡ ç™¾å€ç”šè‡³å‡ åƒå€ã€‚

3.  **`max_iter` (åˆå§‹åŒ–é»‘é­”æ³•)**

      * **é€»è¾‘**ï¼š
          * **`0` æ¬¡è¿­ä»£**ï¼šå¦‚æœä½ åœ¨ ROS ç•Œé¢ç‚¹äº† "Play Initialization"ï¼Œè¿™é‡Œä¼šè¢«è®¾ä¸º 0ã€‚æ±‚è§£å™¨æ„å»ºå®Œé—®é¢˜ç«‹åˆ»åœæ­¢ã€‚
          * **ä½œç”¨**ï¼šè¿™è®©ä½ èƒ½åœ¨ Rviz é‡Œçœ‹åˆ°\*\*â€œä¼˜åŒ–å‰çš„åˆå§‹çŒœæµ‹â€\*\*ï¼ˆæ¯”å¦‚æœºå™¨äººå››è„šæ‚¬ç©ºçš„æ ·å­ï¼‰ï¼Œç”¨äºæ£€æŸ¥åˆå§‹çŠ¶æ€è®¾ç½®å¾—å¯¹ä¸å¯¹ã€‚
          * **`3000` æ¬¡è¿­ä»£**ï¼šæ­£å¸¸çš„è¿è¡Œæ¨¡å¼ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿï¼š**
>
>   * **å¦‚æœæ±‚è§£å™¨ç¬é—´ç»“æŸ**ï¼šæ£€æŸ¥ `msg.play_initialization` æ˜¯å¦è¯¯è§¦ä¸º `true`ã€‚æ­¤æ—¶ä½ ä¼šçœ‹åˆ° `EXIT: Maximum Number of Iterations Exceeded` ä½†è¿­ä»£æ•°æ˜¯ 0ã€‚
>   * **å¦‚æœæ±‚è§£å·¨æ…¢**ï¼šçœ‹ç»ˆç«¯è¾“å‡ºã€‚å¦‚æœæ˜¯ `MUMPS`ï¼Œæ­£å¸¸ï¼›å¦‚æœæ˜¯ `Finite Difference`ï¼Œç»å¯¹é…ç½®é”™äº†ã€‚
>   * **`print_level`**: è®¾ä¸º 5 æ—¶ï¼Œç»ˆç«¯ä¼šç–¯ç‹‚åˆ·å±æ¯ä¸€è½®çš„ `Objective Value`ï¼ˆç›®æ ‡å‡½æ•°å€¼ï¼‰ã€‚å¦‚æœè¿™ä¸ªå€¼åœ¨ä¸æ–­å˜å°ï¼Œè¯´æ˜ä¼˜åŒ–æ­£åœ¨èµ·ä½œç”¨ï¼›å¦‚æœå¡ä½ä¸åŠ¨ï¼Œè¯´æ˜æ‰è¿›å±€éƒ¨æœ€ä¼˜äº†ã€‚

-----
### 6. `Visualization` (åˆå§‹çŠ¶æ€å¯è§†åŒ–)

#### ğŸ‘ï¸ 6.1 `PublishInitialState` (å‘å¸ƒåˆå§‹ç”»é¢)
*è¿™ä¸€æ­¥ä¸å‚ä¸è®¡ç®—ï¼Œçº¯ç²¹ä¸ºäº†ç»™äººçœ‹ã€‚*

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**
```cpp
TowrRosInterface::PublishInitialState()
  {
  int n_ee = formulation_.initial_ee_W_.size();

  // 1. åˆ›å»º XPP çŠ¶æ€å¯¹è±¡ (ä¸­é—´æ ¼å¼)
  xpp::RobotStateCartesian xpp(n_ee);

  // 2. å¡«å……åŸºåº§çŠ¶æ€ (Base)
  xpp.base_.lin.p_ = formulation_.initial_base_.lin.p(); // ä½ç½® (x,y,z)
  // å…³é”®ï¼šå°†æ¬§æ‹‰è§’ (Roll,Pitch,Yaw) è½¬æ¢ä¸ºå››å…ƒæ•° (Quaternion)
  xpp.base_.ang.q  = EulerConverter::GetQuaternionBaseToWorld(formulation_.initial_base_.ang.p());

  // 3. å¡«å……è¶³ç«¯çŠ¶æ€ (Feet)
  for (int ee_towr=0; ee_towr<n_ee; ++ee_towr) {
    // å†æ¬¡ä½¿ç”¨é‚£ä¸ªæ˜ å°„å‡½æ•°ï¼Œè¿™æ¬¡å– .first (ID)
    int ee_xpp = ToXppEndeffector(n_ee, ee_towr).first;
    
    xpp.ee_contact_.at(ee_xpp)   = true; // å‡è®¾åˆå§‹å…¨æ˜¯æ¥è§¦çŠ¶æ€
    xpp.ee_motion_.at(ee_xpp).p_ = formulation_.initial_ee_W_.at(ee_towr); // å¡«å…¥åˆšæ‰è¢«å¼ºåˆ¶è®¾ä¸º 0 çš„åæ ‡
    xpp.ee_forces_.at(ee_xpp).setZero(); // åˆå§‹æ²¡å—åŠ›ï¼Œè®¾ä¸º0
  }

  
// 4. å‘é€ç»™ ROS
initial_state_pub_.publish(xpp::Convert::ToRos(xpp));
}
```
**é€»è¾‘æ·±åº¦è§£æï¼š**

1.  **æ•°æ®æ¡¥æ¥ (`xpp::RobotStateCartesian`)**ï¼š

      * TOWR å†…éƒ¨ç”¨çš„æ˜¯åˆ†æ•£çš„å˜é‡ï¼ˆåŸºåº§ã€åœ°å½¢ã€åŠ›ï¼‰ã€‚
      * ROS (Rviz) åªèƒ½å¬æ‡‚æ ‡å‡†çš„æœºå™¨äººçŠ¶æ€æ¶ˆæ¯ã€‚
      * `xpp` å¯¹è±¡å……å½“äº†ç¿»è¯‘å®˜ã€‚

2.  **æ—‹è½¬è¡¨ç¤ºçš„è½¬æ¢ (`EulerConverter`)**ï¼š

      * **TOWR å†…éƒ¨**ï¼šå–œæ¬¢ç”¨æ¬§æ‹‰è§’ (Euler Angles)ï¼Œå› ä¸ºåªæœ‰ 3 ä¸ªå˜é‡ï¼Œä¼˜åŒ–èµ·æ¥å¿«ã€‚
      * **ROS/Rviz**ï¼šå¼ºåˆ¶ä½¿ç”¨å››å…ƒæ•° (Quaternion, xyzw)ï¼Œå› ä¸ºä¸ä¼šå‡ºç°ä¸‡å‘èŠ‚æ­»é”ã€‚
      * è¿™é‡Œå¿…é¡»åšä¸€æ¬¡æ•°å­¦è½¬æ¢ã€‚

3.  **ID æ˜ å°„çš„å›æ‰£ (`ToXppEndeffector`)**ï¼š

      * è¿˜è®°å¾—ä¹‹å‰çš„ `pair.first` å—ï¼Ÿè¿™é‡Œç”¨åˆ°äº†ï¼
      * å®ƒç¡®ä¿äº† TOWR é‡Œçš„â€œç¬¬0æ¡è…¿â€æ­£ç¡®åœ°å¯¹åº”åˆ°äº† XPP æ¶ˆæ¯é‡Œçš„â€œå·¦å‰è…¿ (LF)â€ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿï¼š**
>
>   * **Rviz é‡Œçš„â€œå¹½çµâ€**ï¼šè¿è¡Œåˆ°è¿™ä¸€æ­¥æ—¶ï¼Œä½ åº”è¯¥èƒ½åœ¨ Rviz é‡Œçœ‹åˆ°ä¸€ä¸ªé™æ­¢çš„æœºå™¨äººæ¨¡å‹ï¼ˆé€šå¸¸æ˜¯åŠé€æ˜çš„æˆ–è€…ç‰¹å®šé¢œè‰²çš„ï¼Œä»£è¡¨ `goal` æˆ– `initial`ï¼‰ã€‚
>   * **æ£€æŸ¥ç‚¹**ï¼š
>       * å®ƒçš„è„šæ˜¯ä¸æ˜¯åˆšå¥½åˆ‡åœ¨ç½‘æ ¼å¹³é¢ ($z=0$) ä¸Šï¼Ÿï¼ˆéªŒè¯ `SetTowrInitialState` æ˜¯å¦ç”Ÿæ•ˆï¼‰ã€‚
>       * å®ƒçš„å¤´æ˜¯ä¸æ˜¯æœå‘æ­£ç¡®çš„æ–¹å‘ï¼Ÿï¼ˆéªŒè¯ `EulerConverter` æ˜¯å¦æ­£ç¡®ï¼‰ã€‚
>       * å¦‚æœæ¨¡å‹æ˜¯æ­ªçš„ã€å€’çš„æˆ–è€…è„šåœ¨å¤´é¡¶ä¸Šï¼Œé—®é¢˜è‚¯å®šå‡ºåœ¨ `formulation_.initial_base_` çš„èµ‹å€¼ä¸Šã€‚

-----


### ğŸ“‚ `Data Structure` (æ•°æ®ç»“æ„å®šä¹‰)

#### ğŸ“¸ `RobotStateCartesian` (æœºå™¨äººç¬›å¡å°”çŠ¶æ€å¸§)
*å®šä¹‰æ–‡ä»¶ï¼š`xpp_msgs/msg/RobotStateCartesian.msg`*

**æ ¸å¿ƒæ¦‚å¿µï¼š**
è¿™æ˜¯ä¸€ä¸ªâ€œå¿«ç…§â€ (Snapshot)ã€‚å®ƒåŒ…å«äº†ä¸€ä¸ªæµ®åŸºæœºå™¨äººåœ¨ $t$ æ—¶åˆ»çš„æ‰€æœ‰è¿åŠ¨å­¦å’ŒåŠ¨åŠ›å­¦ä¿¡æ¯ã€‚

**å­—æ®µé€è¡Œè§£æï¼š**

1.  **`duration time_from_start`**
    * **å«ä¹‰**ï¼š**æ—¶é—´æˆ³**ã€‚
    * **ä½œç”¨**ï¼šè¡¨ç¤ºè¿™ä¸€å¸§å‘ç”Ÿåœ¨è½¨è¿¹å¼€å§‹åçš„ç¬¬å‡ ç§’ï¼ˆä¾‹å¦‚ $t=1.5s$ï¼‰ã€‚æ’­æ”¾è½¨è¿¹æ—¶ï¼ŒROS ä¼šæ ¹æ®è¿™ä¸ªæ—¶é—´æ¥å†³å®šæ’­æ”¾é€Ÿåº¦ã€‚

2.  **`State6d base`**
    * **å«ä¹‰**ï¼š**åŸºåº§ï¼ˆèº¯å¹²ï¼‰çš„ 6è‡ªç”±åº¦çŠ¶æ€**ã€‚
    * **å†…å®¹**ï¼š
        * **ä½ç½® (Linear)**: $x, y, z$ ä»¥åŠ é€Ÿåº¦($\dot{x}$)ã€åŠ é€Ÿåº¦($\ddot{x}$)ã€‚
        * **æ—‹è½¬ (Angular)**: å››å…ƒæ•° (Quaternion) ä»¥åŠ è§’é€Ÿåº¦($\omega$)ã€è§’åŠ é€Ÿåº¦($\dot{\omega}$)ã€‚
    * **ç‰©ç†æ„ä¹‰**ï¼šå†³å®šäº†æœºå™¨äººçš„èº«ä½“åœ¨å“ªé‡Œï¼Œä»¥åŠå®ƒæ˜¯æ€ä¹ˆåŠ¨ã€æ€ä¹ˆè½¬çš„ã€‚

3.  **`StateLin3d[] ee_motion`**
    * **å«ä¹‰**ï¼š**è¶³ç«¯ï¼ˆæœ«ç«¯æ‰§è¡Œå™¨ï¼‰çš„è¿åŠ¨çŠ¶æ€æ•°ç»„**ã€‚
    * **ç±»å‹**ï¼šæ•°ç»„ `[]`ï¼Œé•¿åº¦ç­‰äºè…¿çš„æ•°é‡ (2 æˆ– 4)ã€‚
    * **å†…å®¹**ï¼šæ¯åªè„šåœ¨ä¸–ç•Œåæ ‡ç³»ä¸‹çš„ä½ç½® ($x,y,z$)ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦ã€‚
    * **æ³¨æ„**ï¼šå¦‚æœæ˜¯æ”¯æ’‘ç›¸ï¼Œé€Ÿåº¦é€šå¸¸ä¸º 0ï¼›å¦‚æœæ˜¯æ‘†åŠ¨ç›¸ï¼Œè¿™é‡Œå°±æ˜¯æ‘†åŠ¨è½¨è¿¹ã€‚

4.  **`geometry_msgs/Vector3[] ee_forces`**
    * **å«ä¹‰**ï¼š**è¶³ç«¯æ¥è§¦åŠ› (GRF)**ã€‚
    * **ç‰©ç†æ„ä¹‰**ï¼šåœ°é¢ç»™è„šçš„åä½œç”¨åŠ›ã€‚
    * **å¯è§†åŒ–**ï¼šåœ¨ Rviz é‡Œï¼Œè¿™ä¸ªæ•°æ®é€šå¸¸è¢«ç”»æˆçº¢è‰²çš„ç®­å¤´ã€‚ç®­å¤´è¶Šé•¿ï¼ŒåŠ›è¶Šå¤§ã€‚
    * **TOWR çš„æ ¸å¿ƒ**ï¼šè¿™æ­£æ˜¯ä¼˜åŒ–å™¨ç®—å‡ºæ¥çš„å…³é”®ç»“æœâ€”â€”ä¸ºäº†ä¸æ‘”å€’ï¼Œè„šå¿…é¡»ç”¨å¤šå¤§çš„åŠ›è¹¬åœ°ã€‚

5.  **`bool[] ee_contact`**
    * **å«ä¹‰**ï¼š**æ¥è§¦æ ‡å¿—ä½**ã€‚
    * **å€¼**ï¼š`true` = è¸©åœ¨åœ°ä¸Š (Stance)ï¼›`false` = è…¾ç©º (Swing)ã€‚
    * **ä½œç”¨**ï¼šå‘Šè¯‰å¯è§†åŒ–å·¥å…·æˆ–æ§åˆ¶å™¨ï¼Œå½“å‰è¿™åªè„šæ˜¯ä¸æ˜¯â€œå®â€çš„ã€‚

---
> **ğŸ” è°ƒè¯•æ£€æŸ¥æ¸…å•ï¼š**
> * **æ•°ç»„é•¿åº¦å¯¹ä¸å¯¹ï¼Ÿ** `ee_motion`, `ee_forces`, `ee_contact` çš„é•¿åº¦å¿…é¡»ä¸€è‡´ï¼Œä¸”å¿…é¡»ç­‰äºæœºå™¨äººçš„è…¿æ•° (`n_ee`)ã€‚
> * **åŠ›ä¸æ¥è§¦çš„å¯¹åº”å…³ç³»**ï¼š
>     * å¦‚æœ `ee_contact[i] == false` (è…¾ç©º)ï¼Œé‚£ä¹ˆ `ee_forces[i]` å¿…é¡»éå¸¸æ¥è¿‘ 0ã€‚
>     * å¦‚æœè„šåœ¨ç©ºä¸­å´æœ‰å¾ˆå¤§çš„åŠ›ï¼Œè¯´æ˜ä¼˜åŒ–ç»“æœå‡ºé”™äº†ï¼ˆè¿åç‰©ç†å®šå¾‹ï¼‰ã€‚
---
### 7. `Optimization & Execution` (æ„å»ºä¸æ±‚è§£)

#### ğŸ§  7.1 æ„å»º NLP é—®é¢˜ (`ifopt::Problem`)
**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**
```cpp
if (msg.optimize || msg.play_initialization) {
  nlp_ = ifopt::Problem(); // 1. åˆ›å»ºç©ºé—®é¢˜å®¹å™¨
  
  // 2. æ·»åŠ å˜é‡ (Variables) - æ¯”å¦‚ï¼šæ¯æ¡è…¿æ¯æ—¶åˆ»çš„ä½ç½®
  for (auto c : formulation_.GetVariableSets(solution))
    nlp_.AddVariableSet(c);
    
  // 3. æ·»åŠ çº¦æŸ (Constraints) - æ¯”å¦‚ï¼šè„šä¸èƒ½ç©¿é€åœ°é¢ï¼Œå…³èŠ‚ä¸èƒ½æŠ˜æ–­
  for (auto c : formulation_.GetConstraints(solution))
    nlp_.AddConstraintSet(c);
    
  // 4. æ·»åŠ ä»£ä»· (Costs) - æ¯”å¦‚ï¼šèƒ½é‡æ¶ˆè€—æœ€å°ï¼ŒåŠ¨ä½œæœ€å¹³æ»‘
  for (auto c : formulation_.GetCosts())
    nlp_.AddCostSet(c);

  // 5. æ±‚è§£ï¼ (Blocking Call)
  solver_->Solve(nlp_);
  
  // 6. ä¿å­˜ç»“æœ
  SaveOptimizationAsRosbag(bag_file, robot_params_msg, msg, false);
}
````

**é€»è¾‘æ·±åº¦è§£æï¼š**

  * **`ifopt`**ï¼šè¿™æ˜¯ä¸€ä¸ª C++ ä¼˜åŒ–æ¥å£åº“ï¼ˆ**I**nterface **f**or **Opt**imizationï¼‰ã€‚å®ƒæŠŠæŠ½è±¡çš„ç‰©ç†æ¦‚å¿µè½¬åŒ–ä¸ºæ±‚è§£å™¨ï¼ˆIPOPTï¼‰èƒ½æ‡‚çš„æ•°å­¦çŸ©é˜µã€‚
  * **ç»„è£…è¿‡ç¨‹**ï¼š
      * `GetVariableSets`: æå–æ‰€æœ‰å¾…ä¼˜åŒ–çš„æ•°å€¼ï¼ˆæœªçŸ¥æ•° $x$ï¼‰ã€‚
      * `GetConstraints`: æå–æ‰€æœ‰ $g(x) \leq 0$ å’Œ $h(x) = 0$ã€‚
      * `GetCosts`: æå–æ‰€æœ‰éœ€è¦æœ€å°åŒ–çš„ $f(x)$ã€‚
  * **`solver_->Solve(nlp_)`**:
      * è¿™æ˜¯**æœ€è€—æ—¶**çš„ä¸€è¡Œä»£ç ã€‚
      * ç¨‹åºä¼šåœ¨è¿™é‡Œâ€œå¡ä½â€ï¼Œç›´åˆ° IPOPT æ‰¾åˆ°æœ€ä¼˜è§£æˆ–è€…è¶…æ—¶ã€‚
      * ä¸€æ—¦è¿™è¡Œæ‰§è¡Œå®Œï¼Œ`solution` é‡Œçš„å˜é‡å€¼å°±è¢«æ›´æ–°ä¸º**æœ€ä¼˜è½¨è¿¹**äº†ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿï¼š**
>
>   * **æŒ‰ `v` (visualize) è·¨è¿‡ `Solve` æ—¶**ï¼šæ³¨æ„è§‚å¯Ÿç»ˆç«¯è¾“å‡ºã€‚
>       * `EXIT: Optimal Solution Found.` -\> ğŸ‰ æˆåŠŸï¼
>       * `EXIT: Infeasible Problem.` -\> ğŸ’€ å¤±è´¥ï¼ˆé€šå¸¸æ˜¯çº¦æŸå†²çªï¼Œæ¯”å¦‚è…¿ä¸å¤Ÿé•¿å¤Ÿä¸ç€ç›®æ ‡ï¼‰ã€‚
>   * **æŸ¥çœ‹ `nlp_` è§„æ¨¡**ï¼šåœ¨ `Solve` ä¹‹å‰ï¼Œå¯ä»¥æ£€æŸ¥ `nlp_.GetNumberOfOptimizationVariables()`ã€‚å¯¹äºè¿™ç§é—®é¢˜ï¼Œå˜é‡é€šå¸¸æœ‰å‡ åƒä¸ªã€‚
##### 7.1.1 `NlpFormulation` æ·±åº¦è§£æ

###### â“ ç–‘é—®ï¼šConstraints å’Œ Costs æ˜¯åœ¨å“ªé‡Œå®šä¹‰çš„ï¼Ÿ
**ç­”æ¡ˆï¼š** å®ƒä»¬å®šä¹‰åœ¨ **`Parameters` ç±»çš„æ„é€ å‡½æ•°** ä¸­ï¼ˆé»˜è®¤é›†ï¼‰ï¼Œå¹¶å¯ä»¥åœ¨ `TowrRosApp::GetTowrParameters` ä¸­è¢«ç”¨æˆ·ä¿®æ”¹ã€‚

**å¸¸è§çš„çº¦æŸé›†åˆ (`params_.constraints_`)<-src/towr/towr/src/parameters.cc åŒ…æ‹¬ï¼š**
1.  **`Dynamic`**: åŠ¨åŠ›å­¦çº¦æŸ (F=ma)ã€‚
2.  **`EndeffectorRom`**: è¿åŠ¨å­¦èŒƒå›´çº¦æŸ (Range of Motion, è…¿é•¿é™åˆ¶)ã€‚
3.  **`BaseRom`**: åŸºåº§æ´»åŠ¨èŒƒå›´ (é€šå¸¸ä¸å¼€å¯ï¼Œé™¤éåœ¨å—é™ç©ºé—´)ã€‚
4.  **`Terrain`**: åœ°å½¢å‡ ä½•çº¦æŸ (è„šå¿…é¡»è½åœ¨åœ°å½¢è¡¨é¢ $z=h(x,y)$)ã€‚
5.  **`Force`**: æ‘©æ“¦é”¥ (Friction Cone) å’Œæ³•å‘åŠ›çº¦æŸ (ä¸èƒ½æ‰“æ»‘ï¼ŒåŠ›å¿…é¡» > 0)ã€‚

**å¸¸è§çš„ Cost é›†åˆ (`params_.costs_`) åŒ…æ‹¬ï¼š**
1.  **`ForcesCost`**: æœ€å°åŒ–å…³èŠ‚åŠ›/åŠ›çŸ© (çœç”µ)ã€‚
2.  **`SoftConstraint`**: é’ˆå¯¹ä¸€äº›ç¡¬çº¦æŸçš„æ¾å¼›æƒ©ç½šã€‚

###### ğŸ­ æµç¨‹å›¾è§£
1.  **`GetVariableSets`**: åˆ›å»ºå‡ åƒä¸ªçº¯æ•°å­—å˜é‡ (Vars)ã€‚
    â†“
2.  **`SplineHolder`**: å°†æ•°å­—è¿æˆå¹³æ»‘çš„æ›²çº¿ (Splines)ã€‚
    â†“
3.  **`GetConstraints`**: æ‹¿ç€æ›²çº¿å»æ£€æŸ¥ç‰©ç†å®šå¾‹ (æ¯”å¦‚æ£€æŸ¥æ›²çº¿çš„äºŒé˜¶å¯¼æ•° $a$ æ˜¯å¦åŒ¹é… $F/m$)ã€‚

-----

#### ğŸ¬ 7.2 ç»“æœå›æ”¾ä¸åˆ†æ (`System Calls`)

**ä»£ç æ ¸å¿ƒé€»è¾‘ï¼š**

```cpp
// 1. è‡ªåŠ¨å›æ”¾ (è°ƒç”¨å‘½ä»¤è¡Œ)
if (msg.replay_trajectory || ...) {
  int success = system(("rosbag play --topics ... " + bag_file).c_str());
}

// 2. ç»˜åˆ¶å›¾è¡¨ (è°ƒç”¨ rqt_bag)
if (msg.plot_trajectory) {
  system(("killall rqt_bag; rqt_bag " + bag_file + "&").c_str());
}
```

**é€»è¾‘è§£æï¼š**

  * **`system(...)`**ï¼šè¿™æ˜¯ä¸€ä¸ª C++ æ ‡å‡†åº“å‡½æ•°ï¼Œç”¨æ¥**åœ¨ç»ˆç«¯é‡Œæ‰§è¡Œ shell å‘½ä»¤**ã€‚
  * å®ƒå®é™…ä¸Šæ˜¯åœ¨ä½ çš„åå°å·å·æ•²äº† `rosbag play towr_trajectory.bag`ã€‚
  * **ä½œç”¨**ï¼š
      * æŠŠåˆšæ‰ç®—å‡ºå¹¶ä¿å­˜çš„ `.bag` æ–‡ä»¶æ’­æ”¾å‡ºæ¥ã€‚
      * æ­¤æ—¶ï¼ŒRviz è®¢é˜…äº†ç›¸å…³è¯é¢˜ï¼Œå°±ä¼šåƒçœ‹ç”µå½±ä¸€æ ·æ˜¾ç¤ºæœºå™¨äººçš„è¿åŠ¨è½¨è¿¹ã€‚

> **ğŸ” è°ƒè¯•è§‚å¯Ÿï¼š**
>
>   * **å¦‚æœ Rviz æ²¡ååº”**ï¼š
>       * æ£€æŸ¥ `bag_file` è·¯å¾„ï¼ˆé»˜è®¤åœ¨ `~/.ros/` ä¸‹ï¼‰ã€‚
>       * æ£€æŸ¥ç»ˆç«¯é‡Œæœ‰æ²¡æœ‰æŠ¥é”™ `rosbag: command not found`ï¼ˆæ²¡è£… rosbagï¼‰ã€‚
>   * **ä¸ºä»€ä¹ˆè¦ `killall rqt_bag`**ï¼šé˜²æ­¢ä½ ç‚¹å¤šæ¬¡æŒ‰é’®æ‰“å¼€æ— æ•°ä¸ªç»˜å›¾çª—å£ï¼Œå…ˆæ€æ‰æ—§çš„å†å¼€æ–°çš„ã€‚

-----

```